---
alwaysApply: true
---
<laravel-boost-guidelines>
=== foundation rules ===

# Laravel Boost Guidelines

The Laravel Boost guidelines are specifically curated by Laravel maintainers for this application. These guidelines should be followed closely to enhance the user's satisfaction building Laravel applications.

## Foundational Context
This application is a Laravel application and its main Laravel ecosystems package & versions are below. You are an expert with them all. Ensure you abide by these specific packages & versions.

- php - 8.4.16
- laravel/framework (LARAVEL) - v12
- laravel/octane (OCTANE) - v2
- laravel/prompts (PROMPTS) - v0
- laravel/sanctum (SANCTUM) - v4
- livewire/livewire (LIVEWIRE) - v4
- laravel/breeze (BREEZE) - v2
- laravel/mcp (MCP) - v0
- laravel/pint (PINT) - v1
- laravel/sail (SAIL) - v1
- phpunit/phpunit (PHPUNIT) - v11
- rector/rector (RECTOR) - v2
- alpinejs (ALPINEJS) - v3
- tailwindcss (TAILWINDCSS) - v3


## Conventions
- You must follow all existing code conventions used in this application. When creating or editing a file, check sibling files for the correct structure, approach, naming.
- Use descriptive names for variables and methods. For example, `isRegisteredForDiscounts`, not `discount()`.
- Check for existing components to reuse before writing a new one.

## Verification Scripts
- Do not create verification scripts or tinker when tests cover that functionality and prove it works. Unit and feature tests are more important.

## Application Structure & Architecture
- Stick to existing directory structure - don't create new base folders without approval.
- Do not change the application's dependencies without approval.

## Frontend Bundling
- If the user doesn't see a frontend change reflected in the UI, it could mean they need to run `npm run build`, `npm run dev`, or `composer run dev`. Ask them.

## Replies
- Be concise in your explanations - focus on what's important rather than explaining obvious details.

## Documentation Files
- You must only create documentation files if explicitly requested by the user.


=== boost rules ===

## Laravel Boost
- Laravel Boost is an MCP server that comes with powerful tools designed specifically for this application. Use them.

## Artisan
- Use the `list-artisan-commands` tool when you need to call an Artisan command to double check the available parameters.

## URLs
- Whenever you share a project URL with the user you should use the `get-absolute-url` tool to ensure you're using the correct scheme, domain / IP, and port.

## Tinker / Debugging
- You should use the `tinker` tool when you need to execute PHP to debug code or query Eloquent models directly.
- Use the `database-query` tool when you only need to read from the database.

## Reading Browser Logs With the `browser-logs` Tool
- You can read browser logs, errors, and exceptions using the `browser-logs` tool from Boost.
- Only recent browser logs will be useful - ignore old logs.

## Searching Documentation (Critically Important)
- Boost comes with a powerful `search-docs` tool you should use before any other approaches. This tool automatically passes a list of installed packages and their versions to the remote Boost API, so it returns only version-specific documentation specific for the user's circumstance. You should pass an array of packages to filter on if you know you need docs for particular packages.
- The 'search-docs' tool is perfect for all Laravel related packages, including Laravel, Inertia, Livewire, Filament, Tailwind, Pest, Nova, Nightwatch, etc.
- You must use this tool to search for Laravel-ecosystem documentation before falling back to other approaches.
- Search the documentation before making code changes to ensure we are taking the correct approach.
- Use multiple, broad, simple, topic based queries to start. For example: `['rate limiting', 'routing rate limiting', 'routing']`.
- Do not add package names to queries - package information is already shared. For example, use `test resource table`, not `filament 4 test resource table`.

### Available Search Syntax
- You can and should pass multiple queries at once. The most relevant results will be returned first.

1. Simple Word Searches with auto-stemming - query=authentication - finds 'authenticate' and 'auth'
2. Multiple Words (AND Logic) - query=rate limit - finds knowledge containing both "rate" AND "limit"
3. Quoted Phrases (Exact Position) - query="infinite scroll" - Words must be adjacent and in that order
4. Mixed Queries - query=middleware "rate limit" - "middleware" AND exact phrase "rate limit"
5. Multiple Queries - queries=["authentication", "middleware"] - ANY of these terms


=== php rules ===

## PHP

- Always use curly braces for control structures, even if it has one line.

### Constructors
- Use PHP 8 constructor property promotion in `__construct()`.
    - <code-snippet>public function __construct(public GitHub $github) { }</code-snippet>
- Do not allow empty `__construct()` methods with zero parameters.

### Type Declarations
- Always use explicit return type declarations for methods and functions.
- Use appropriate PHP type hints for method parameters.

<code-snippet name="Explicit Return Types and Method Params" lang="php">
protected function isAccessible(User $user, ?string $path = null): bool
{
    ...
}
</code-snippet>

## Comments
- Prefer PHPDoc blocks over comments. Never use comments within the code itself unless there is something _very_ complex going on.

## PHPDoc Blocks
- Add useful array shape type definitions for arrays when appropriate.

## Enums
- Typically, keys in an Enum should be TitleCase. For example: `FavoritePerson`, `BestLake`, `Monthly`.


=== laravel/core rules ===

## Do Things the Laravel Way

- Use `php artisan make:` commands to create new files (i.e. migrations, controllers, models, etc.). You can list available Artisan commands using the `list-artisan-commands` tool.
- If you're creating a generic PHP class, use `artisan make:class`.
- Pass `--no-interaction` to all Artisan commands to ensure they work without user input. You should also pass the correct `--options` to ensure correct behavior.

### Database
- Always use proper Eloquent relationship methods with return type hints. Prefer relationship methods over raw queries or manual joins.
- Use Eloquent models and relationships before suggesting raw database queries
- Avoid `DB::`; prefer `Model::query()`. Generate code that leverages Laravel's ORM capabilities rather than bypassing them.
- Generate code that prevents N+1 query problems by using eager loading.
- Use Laravel's query builder for very complex database operations.

### Model Creation
- When creating new models, create useful factories and seeders for them too. Ask the user if they need any other things, using `list-artisan-commands` to check the available options to `php artisan make:model`.

### APIs & Eloquent Resources
- For APIs, default to using Eloquent API Resources and API versioning unless existing API routes do not, then you should follow existing application convention.

### Controllers & Validation
- Always create Form Request classes for validation rather than inline validation in controllers. Include both validation rules and custom error messages.
- Check sibling Form Requests to see if the application uses array or string based validation rules.

### Queues
- Use queued jobs for time-consuming operations with the `ShouldQueue` interface.

### Authentication & Authorization
- Use Laravel's built-in authentication and authorization features (gates, policies, Sanctum, etc.).

### URL Generation
- When generating links to other pages, prefer named routes and the `route()` function.

### Configuration
- Use environment variables only in configuration files - never use the `env()` function directly outside of config files. Always use `config('app.name')`, not `env('APP_NAME')`.

### Testing
- When creating models for tests, use the factories for the models. Check if the factory has custom states that can be used before manually setting up the model.
- Faker: Use methods such as `$this->faker->word()` or `fake()->randomDigit()`. Follow existing conventions whether to use `$this->faker` or `fake()`.
- When creating tests, make use of `php artisan make:test [options] <name>` to create a feature test, and pass `--unit` to create a unit test. Most tests should be feature tests.

### Vite Error
- If you receive an "Illuminate\Foundation\ViteException: Unable to locate file in Vite manifest" error, you can run `npm run build` or ask the user to run `npm run dev` or `composer run dev`.


=== laravel/v12 rules ===

## Laravel 12

- Use the `search-docs` tool to get version specific documentation.
- This project upgraded from Laravel 10 without migrating to the new streamlined Laravel file structure.
- This is **perfectly fine** and recommended by Laravel. Follow the existing structure from Laravel 10. We do not to need migrate to the new Laravel structure unless the user explicitly requests that.

### Laravel 10 Structure
- Middleware typically lives in `app/Http/Middleware/` and service providers in `app/Providers/`.
- There is no `bootstrap/app.php` application configuration in a Laravel 10 structure:
    - Middleware registration happens in `app/Http/Kernel.php`
    - Exception handling is in `app/Exceptions/Handler.php`
    - Console commands and schedule register in `app/Console/Kernel.php`
    - Rate limits likely exist in `RouteServiceProvider` or `app/Http/Kernel.php`

### Database
- When modifying a column, the migration must include all of the attributes that were previously defined on the column. Otherwise, they will be dropped and lost.
- Laravel 11 allows limiting eagerly loaded records natively, without external packages: `$query->latest()->limit(10);`.

### Models
- Casts can and likely should be set in a `casts()` method on a model rather than the `$casts` property. Follow existing conventions from other models.


=== livewire/core rules ===

## Livewire Core
- Use the `search-docs` tool to find exact version specific documentation for how to write Livewire & Livewire tests.
- Use the `php artisan make:livewire [Posts\\CreatePost]` artisan command to create new components
- State should live on the server, with the UI reflecting it.
- All Livewire requests hit the Laravel backend, they're like regular HTTP requests. Always validate form data, and run authorization checks in Livewire actions.

## Livewire Best Practices
- Livewire components require a single root element.
- Use `wire:loading` and `wire:dirty` for delightful loading states.
- Add `wire:key` in loops:

    ```blade
    @foreach ($items as $item)
        <div wire:key="item-{{ $item->id }}">
            {{ $item->name }}
        </div>
    @endforeach
    ```

- Prefer lifecycle hooks like `mount()`, `updatedFoo()` for initialization and reactive side effects:

<code-snippet name="Lifecycle hook examples" lang="php">
    public function mount(User $user) { $this->user = $user; }
    public function updatedSearch() { $this->resetPage(); }
</code-snippet>


## Testing Livewire

<code-snippet name="Example Livewire component test" lang="php">
    Livewire::test(Counter::class)
        ->assertSet('count', 0)
        ->call('increment')
        ->assertSet('count', 1)
        ->assertSee(1)
        ->assertStatus(200);
</code-snippet>


    <code-snippet name="Testing a Livewire component exists within a page" lang="php">
        $this->get('/posts/create')
        ->assertSeeLivewire(CreatePost::class);
    </code-snippet>


=== livewire/v4 rules ===

## Livewire 4

### New features: component formats (v4)
- v4 adds **single-file** and **multi-file** component formats alongside traditional class + view. **Single-file:** PHP and Blade in one file (default for `make:livewire`). **Multi-file:** PHP, Blade, JavaScript, and tests in a directory (use `--mfc`). View-based component files can be prefixed with a ⚡ emoji to distinguish them in the editor (disable via `make_command.emoji` config). Use `php artisan livewire:convert <name>` to convert between formats.

<code-snippet name="Livewire v4 component commands" lang="bash">
php artisan make:livewire create-post        # Single-file (default)
php artisan make:livewire create-post --mfc  # Multi-file component
php artisan livewire:convert create-post     # Convert between formats
</code-snippet>

### Slots and attribute forwarding (v4)
- Components support **slots** and **automatic attribute bag forwarding** via `{{ $attributes }}`, making component composition and nesting more flexible. Use the documentation to learn more about nesting components.

### JavaScript in view-based components (v4)
- View-based components can include `<script>` tags without the `@script` wrapper. Scripts are served as separate cached files for better performance and get automatic `$wire` binding: `this` is bound like `$wire` inside the script (e.g. `this.count++` is equivalent to `$wire.count++`); `$wire` remains available (e.g. `$wire.save()`).

<code-snippet name="View-based component script (v4)" lang="html">
<div>
    <!-- Your component template -->
</div>

<script>
    // $wire is automatically bound as 'this'
    this.count++  // Same as $wire.count++

    // $wire is still available if preferred
    $wire.save()
</script>
</code-snippet>

### Islands (v4)
- **Islands** are isolated regions inside a component that update on their own, improving performance without separate child components. Use `@island(name: '...', lazy: true)` / `@endisland`. See the documentation for more on islands.

<code-snippet name="Island directive (v4)" lang="html">
@island(name: 'stats', lazy: true)
    <div>{{ $this->expensiveStats }}</div>
@endisland
</code-snippet>

### Deferred loading (v4)
- In addition to **lazy** (viewport-based) loading, components can be **deferred** to load right after the initial page load. Use the `defer` attribute on the tag or the `#[Defer]` attribute on the component class.

<code-snippet name="Defer loading (v4)" lang="html">
<livewire:revenue defer />
</code-snippet>

<code-snippet name="Defer attribute on component (v4)" lang="php">
#[Defer]
class Revenue extends Component { ... }
</code-snippet>

### Bundled loading (v4)
- You can control whether multiple lazy or deferred components load in **parallel** or **bundled** in one request. Use the `.bundle` modifier on the tag or `bundle: true` in the attribute. See the documentation for lazy and deferred loading.

<code-snippet name="Bundled loading (v4)" lang="html">
<livewire:revenue lazy.bundle />
<livewire:expenses defer.bundle />
</code-snippet>

<code-snippet name="Lazy bundle attribute (v4)" lang="php">
#[Lazy(bundle: true)]
class Revenue extends Component { ... }
</code-snippet>

### Async actions (v4)
- Run actions in **parallel** without blocking other requests using the `.async` modifier on the wire directive or the `#[Async]` attribute on the method.

<code-snippet name="Async wire:click (v4)" lang="html">
<button wire:click.async="logActivity">Track</button>
</code-snippet>

<code-snippet name="Async method attribute (v4)" lang="php">
#[Async]
public function logActivity() { ... }
</code-snippet>

### wire:sort – drag-and-drop sorting (v4)
- **wire:sort** adds built-in support for sortable lists with drag-and-drop. Put `wire:sort="methodName"` on the list and `wire:sort:item="{{ $id }}"` (plus `wire:key`) on each item. Use the documentation for full details.

<code-snippet name="wire:sort (v4)" lang="html">
<ul wire:sort="updateOrder">
    @foreach ($items as $item)
        <li wire:sort:item="{{ $item->id }}" wire:key="{{ $item->id }}">{{ $item->name }}</li>
    @endforeach
</ul>
</code-snippet>

### wire:intersect – viewport intersection (v4)
- **wire:intersect** runs actions when elements enter or leave the viewport (similar to Alpine's x-intersect). Use the documentation for full details. **Modifiers:** `.once` (fire only once), `.half` (half visible), `.full` (fully visible), `.threshold.X` (visibility 0–100%), `.margin.Xpx` or `.margin.X%` (intersection margin). Use `:leave` to run when leaving the viewport.

<code-snippet name="wire:intersect (v4)" lang="html">
<!-- Basic -->
<div wire:intersect="loadMore">...</div>

<!-- Modifiers -->
<div wire:intersect.once="trackView">...</div>
<div wire:intersect:leave="pauseVideo">...</div>
<div wire:intersect.half="loadMore">...</div>
<div wire:intersect.full="startAnimation">...</div>
<div wire:intersect.margin.200px="loadMore">...</div>
<div wire:intersect.threshold.50="trackScroll">...</div>
</code-snippet>

### wire:ref – element references (v4)
- **wire:ref** lets you reference and interact with elements from the template and JavaScript. Set `wire:ref="name"` on the element; access it as `this.$refs.name` in scripts. Use with `$js` for actions (e.g. `wire:click="$js.scrollToModal"` and `this.$js.scrollToModal = () => this.$refs.modal.scrollIntoView()`). See the documentation for more.

<code-snippet name="wire:ref (v4)" lang="html">
<div wire:ref="modal"><!-- Modal content --></div>
<button wire:click="$js.scrollToModal">Scroll to modal</button>
<script>
    this.$js.scrollToModal = () => {
        this.$refs.modal.scrollIntoView()
    }
</script>
</code-snippet>

### .renderless and .preserve-scroll modifiers (v4)
- **.renderless:** Skip component re-render for an action (e.g. `wire:click.renderless="trackClick"`). Use for actions that don't need to update the UI; alternative to the `#[Renderless]` attribute.
- **.preserve-scroll:** Keep scroll position during updates to avoid layout jumps (e.g. `wire:click.preserve-scroll="loadMore"`).

<code-snippet name="renderless and preserve-scroll (v4)" lang="html">
<button wire:click.renderless="trackClick">Track</button>
<button wire:click.preserve-scroll="loadMore">Load More</button>
</code-snippet>

### data-loading attribute (v4)
- Any element that triggers a network request gets a **data-loading** attribute while the request runs. Style loading state with Tailwind using `data-loading:` variants.

<code-snippet name="data-loading styling (v4)" lang="html">
<button wire:click="save" class="data-loading:opacity-50 data-loading:pointer-events-none">
    Save Changes
</button>
</code-snippet>

### JavaScript: $errors magic property (v4)
- Access the component's **error bag** from JavaScript. Use `$errors.has('field')`, `$errors.first('field')`, etc. in directives like `wire:show` and `wire:text`. See the validation documentation for more.

<code-snippet name="$errors in template (v4)" lang="html">
<div wire:show="$errors.has('email')">
    <span wire:text="$errors.first('email')"></span>
</div>
</code-snippet>

### JavaScript: $intercept (v4)
- **$intercept** lets you intercept and modify Livewire requests from JavaScript (e.g. before a method runs or to change payload/response). See the JavaScript interceptors documentation for more.

<code-snippet name="$intercept (v4)" lang="html">
<script>
this.$intercept('save', ({ ... }) => {
    // ...
})
</script>
</code-snippet>

### Island targeting from template (v4)
- Trigger island updates from the template with **wire:island.*** modifiers. Use `wire:island.append="islandName"` (or similar) so an action refreshes or appends to a specific island.

<code-snippet name="wire:island targeting (v4)" lang="html">
<button wire:click="loadMore" wire:island.append="stats">
    Load more
</button>
</code-snippet>

### wire:model modifiers and client-side sync (v4)
- In v3, modifiers like `.blur` and `.change` only controlled when **network** requests were sent; the input value was still synced to client-side state (`$wire.property`) as the user typed. In v4, these modifiers also control **when client-side state** syncs, enabling patterns like inputs that don't update until the user blurs or presses Enter.
- **Migration:** If you use `.blur` or `.change` and want the old behavior, add `.live` before the modifier: `wire:model.blur` → `wire:model.live.blur`, `wire:model.change` → `wire:model.live.change`. `wire:model.lazy` is backwards compatible—no change needed.
- **New in v4:** You can delay client-side updates without sending network requests (e.g. `wire:model.blur="width"` to update only on blur; `wire:model.blur.enter="search"` to update on Enter or blur).

<code-snippet name="wire:model modifier migration (v4)" lang="html">
<!-- v3 -->
<input wire:model.blur="title">

<!-- v4 equivalent (old behavior) -->
<input wire:model.live.blur="title">

<!-- v4 only: update $wire when user tabs away, no request until blur -->
<input wire:model.blur="width">

<!-- v4 only: update on Enter or blur -->
<input wire:model.blur.enter="search">
</code-snippet>

### wire:model and child events (v4)
- In v4, `wire:model` only listens for events on the element itself (like `.self`); it no longer responds to input/change events that bubble up from children. This avoids issues when `wire:model` is on a container (e.g. modal, accordion) that has form inputs inside. To capture events from child elements again, add the `.deep` modifier (e.g. `wire:model.deep="value"`). Standard bindings on inputs, selects, and textareas are unchanged; the change mainly affects `wire:model` on container elements.

<code-snippet name="wire:model deep modifier (v4)" lang="html">
<!-- Before (v3) - listened to child events by default -->
<div wire:model="value">
    <input type="text">
</div>

<!-- After (v4) - add .deep to restore old behavior -->
<div wire:model.deep="value">
    <input type="text">
</div>
</code-snippet>

### Routing (v4)
- For full-page components, use `Route::livewire()` instead of `Route::get()`. The old style still works but is not recommended; `Route::livewire()` is required for single-file and multi-file components to work correctly as full-page components.

<code-snippet name="Livewire 4 routing" lang="php">
// Before (v3) - still works but not recommended
Route::get('/dashboard', Dashboard::class);

// After (v4) - recommended for all component types
Route::livewire('/dashboard', Dashboard::class);

// View-based components: use the component name
Route::livewire('/dashboard', 'pages::dashboard');
</code-snippet>

### wire:navigate:scroll (v4)
- When preserving scroll in a scrollable container across `wire:navigate` requests, use `wire:navigate:scroll` in v4 instead of `wire:scroll`.

<code-snippet name="wire:navigate:scroll (v4)" lang="html">
@persist('sidebar')
    <div class="overflow-y-scroll" wire:navigate:scroll>
        <!-- ... -->
    </div>
@endpersist
</code-snippet>

### Component tags must be closed (v4)
- In v4, Livewire component tags must be properly closed. With slot support, an unclosed tag causes Livewire to treat following content as slot content and the component may not render. Use a self-closing tag or an explicit closing tag.

<code-snippet name="Livewire component tag (v4)" lang="html">
<!-- Before (v3) - unclosed tag -->
<livewire:component-name>

<!-- After (v4) - self-closing -->
<livewire:component-name />
</code-snippet>

### wire:transition uses View Transitions API (v4)
- In v3, `wire:transition` wrapped Alpine's `x-transition` and supported modifiers such as `.opacity`, `.scale`, `.duration.200ms`, and `.origin.top`. In v4, `wire:transition` uses the browser's native View Transitions API. Plain `wire:transition` still works (elements fade in and out); all modifiers have been removed and are no longer supported.

<code-snippet name="wire:transition (v4)" lang="html">
<!-- Still works in v4 -->
<div wire:transition>...</div>

<!-- No longer supported in v4 -->
<div wire:transition.opacity>...</div>
<div wire:transition.scale.origin.top>...</div>
<div wire:transition.duration.500ms>...</div>
</code-snippet>

### Update hooks consolidate array/object changes (v4)
- When the frontend replaces an entire array or object (e.g. `$wire.items = ['new', 'values']`), Livewire v4 sends a **single consolidated update** instead of granular per-index updates. `updatingItems` / `updatedItems` (and equivalent hooks) fire **once** with the full new value, matching v2 behavior. In v3, the same operation could fire hooks multiple times (once per index change plus `__rm__` removals). If your code depends on per-index hooks when replacing whole arrays, it may need to be updated. Single-item changes (e.g. `wire:model="items.0"`) still trigger granular hooks as before.

### Method signature changes (v4)
- If you extend Livewire or call these methods directly, update for v4. **Streaming:** The `stream()` method parameter order changed and the `to` parameter was renamed to `el`. **Component mounting (internal):** If you extend `LivewireManager` or call `mount()` directly, v4 adds a fourth parameter `$slots = []` for slot support; most applications are unaffected.

<code-snippet name="stream() signature (v4)" lang="php">
// Before (v3) - named parameters
$this->stream(to: '#container', content: 'Hello', replace: true);

// After (v4) - named parameters (to → el, content first)
$this->stream(content: 'Hello', replace: true, el: '#container');

// Before (v3) - positional parameters
$this->stream('#container', 'Hello');

// After (v4) - positional then named
$this->stream('Hello', el: '#container');
</code-snippet>

<code-snippet name="mount() signature (v4 internal)" lang="php">
// Before (v3)
public function mount($name, $params = [], $key = null)

// After (v4) - adds $slots for slot support
public function mount($name, $params = [], $key = null, $slots = [])
</code-snippet>

### Livewire asset and endpoint URL changes (v4, low-impact)
- All Livewire URLs now include a unique hash derived from `APP_KEY`. The prefix changed from `/livewire/` to `/livewire-{hash}/`. If firewall rules, CDN config, or middleware reference `/livewire/` paths, update them to use or allow the new prefix (e.g. pattern like `/livewire-*/` or read the hash at runtime).

| v3 | v4 |
|----|-----|
| `/livewire/update` | `/livewire-{hash}/update` |
| `/livewire/upload-file` | `/livewire-{hash}/upload-file` |
| `/livewire/livewire.js` | `/livewire-{hash}/livewire.js` |

### JavaScript deprecations (v4)
- **$wire.$js() / $js():** The `$wire.$js('name', fn)` and bare `$js('name', fn)` forms are deprecated. Use property assignment: `$wire.$js.bookmark = () => { ... }` or `this.$js.bookmark = () => { ... }`. Old syntax still works in v4 but should be migrated when convenient.
- **commit and request hooks:** `Livewire.hook('commit', ...)` and `Livewire.hook('request', ...)` are deprecated in favor of the interceptor API. Use `Livewire.interceptMessage(...)` instead of `commit`, and `Livewire.interceptRequest(...)` instead of `request`. The new system gives more granular error handling (e.g. `onError` vs `onFailure`), better lifecycle hooks, cancellation support, and component-scoped interceptors via `$wire.intercept(...)`. Deprecated hooks still work in v4; migrate when convenient.

<code-snippet name="$js new syntax (v4)" lang="js">
// Deprecated (v3)
$wire.$js('bookmark', () => { /* ... */ });
$js('bookmark', () => { /* ... */ });

// New (v4)
$wire.$js.bookmark = () => { /* ... */ };
// Or: this.$js.bookmark = () => { /* ... */ };
</code-snippet>

<code-snippet name="commit hook → interceptMessage (v4)" lang="js">
// OLD - Deprecated
Livewire.hook('commit', ({ component, commit, respond, succeed, fail }) => {
    respond(() => { /* after response, before processing */ });
    succeed(({ snapshot, effects }) => { /* ... */ });
    fail(() => { /* ... */ });
});

// NEW - Recommended
Livewire.interceptMessage(({ component, message, onFinish, onSuccess, onError, onFailure }) => {
    onFinish(() => { /* like respond() */ });
    onSuccess(({ payload }) => { /* snapshot: payload.snapshot, effects: payload.effects */ });
    onError(() => { /* server errors */ });
    onFailure(() => { /* network errors */ });
});
</code-snippet>

<code-snippet name="request hook → interceptRequest (v4)" lang="js">
// OLD - Deprecated
Livewire.hook('request', ({ url, options, payload, respond, succeed, fail }) => { ... });

// NEW - Recommended (see Lifecycle Hooks in this rule for full example)
Livewire.interceptRequest(({ request, onResponse, onSuccess, onError, onFailure }) => {
    // request.uri, request.options, request.payload
    onResponse(({ response }) => { /* like respond(); status: response.status */ });
    onSuccess(({ response, responseJson }) => { /* like succeed() */ });
    onError(({ response, responseBody, preventDefault }) => { /* server errors */ });
    onFailure(({ error }) => { /* network errors */ });
});
</code-snippet>

### Upgrading from Volt to Livewire v4 single-file components
- Livewire v4 supports single-file components with the same style as Volt class-based components. You can migrate from Volt by updating imports, routes, and tests as below. **Component imports:** Use `Livewire\Component` instead of `Livewire\Volt\Component`. **Routes:** Use `Route::livewire()` instead of `Volt::route()`. **Tests:** Use `Livewire::test()` and `use Livewire\Livewire` instead of `Volt::test()` and `use Livewire\Volt\Volt`.

<code-snippet name="Volt → Livewire v4 component import" lang="php">
// Before (Volt)
use Livewire\Volt\Component;
new class extends Component { ... }

// After (Livewire v4)
use Livewire\Component;
new class extends Component { ... }
</code-snippet>

<code-snippet name="Volt → Livewire v4 routes" lang="php">
// Before (Volt)
use Livewire\Volt\Volt;
Volt::route('/dashboard', 'dashboard');

// After (Livewire v4)
use Illuminate\Support\Facades\Route;
Route::livewire('/dashboard', 'dashboard');
</code-snippet>

<code-snippet name="Volt → Livewire v4 tests" lang="php">
// Before (Volt)
use Livewire\Volt\Volt;
Volt::test('counter')

// After (Livewire v4)
use Livewire\Livewire;
Livewire::test('counter')
</code-snippet>

- **Remove Volt service provider:** Delete `app/Providers/VoltServiceProvider.php`, then remove its entry from the `providers` array in `bootstrap/providers.php` (e.g. remove `App\Providers\VoltServiceProvider::class`). **Remove Volt package:** Run `composer remove livewire/volt`.

<code-snippet name="Volt provider removal (bootstrap/providers.php)" lang="php">
// Before
return [
    App\Providers\AppServiceProvider::class,
    App\Providers\VoltServiceProvider::class,
];

// After
return [
    App\Providers\AppServiceProvider::class,
];
</code-snippet>

### Key Changes From Livewire 2
- These things changed in Livewire 2, but may not have been updated in this application. Verify this application's setup to ensure you conform with application conventions.
    - Use `wire:model.live` for real-time updates, `wire:model` is now deferred by default.
    - Components now use the `App\Livewire` namespace (not `App\Http\Livewire`).
    - Use `$this->dispatch()` to dispatch events (not `emit` or `dispatchBrowserEvent`).
    - Use the `components.layouts.app` view as the typical layout path (not `layouts.app`).

### New Directives
- `wire:show`, `wire:transition`, `wire:cloak`, `wire:offline`, `wire:target` are available for use. Use the documentation to find usage examples.

### Alpine
- Alpine is now included with Livewire, don't manually include Alpine.js.
- Plugins included with Alpine: persist, intersect, collapse, and focus.

### Lifecycle Hooks
- You can listen for `livewire:init` to hook into Livewire initialization. For v4, use the interceptor API instead of deprecated `Livewire.hook('request', ...)` and `Livewire.hook('commit', ...)`; see **JavaScript deprecations (v4)** in this rule for migration. Example using `Livewire.interceptRequest` (e.g. session expiry / errors):

<code-snippet name="livewire:init with interceptRequest (v4)" lang="js">
document.addEventListener('livewire:init', function () {
    Livewire.interceptRequest(({ onResponse, onSuccess, onError, onFailure }) => {
        onResponse(({ response }) => {
            // Runs when response received
        });
        onSuccess(({ response, responseJson }) => {
            // Runs on successful response
        });
        onError(({ response, responseBody, preventDefault }) => {
            if (response?.status === 419) {
                alert('Your session expired');
            }
            console.error(responseBody);
        });
        onFailure(({ error }) => {
            console.error('Livewire request failed', error);
        });
    });
});
</code-snippet>


=== single-file components (livewire v4) ===

## Single-file components (Livewire v4)

- With Livewire v4, **Volt is not required**. Use Livewire's built-in single-file components: same class-based style (PHP logic and Blade in one file), but extend `Livewire\Component` and use `Route::livewire()` and `Livewire::test()`. See **Upgrading from Volt to Livewire v4 single-file components** in the Livewire 4 rules for migration from Volt.
- For new interactivity, create single-file Livewire components (e.g. `php artisan make:livewire ComponentName` and use one file, or the same pattern as below with `Livewire\Component`).

### Single-file component example (Livewire v4)

<code-snippet name="Livewire v4 single-file component" lang="php">
use Livewire\Component;

new class extends Component {
    public $count = 0;

    public function increment()
    {
        $this->count++;
    }
} ?>

<div>
    <h1>{{ $count }}</h1>
    <button wire:click="increment">+</button>
</div>
</code-snippet>


### Testing single-file components
- Use the existing directory for tests if it already exists. Otherwise, fallback to `tests/Feature/Livewire` or similar.

<code-snippet name="Livewire single-file test example" lang="php">
use Livewire\Livewire;

test('counter increments', function () {
    Livewire::test('counter')
        ->assertSee('Count: 0')
        ->call('increment')
        ->assertSee('Count: 1');
});
</code-snippet>


<code-snippet name="Single-file component test with auth" lang="php">
declare(strict_types=1);

use App\Models\{User, Product};
use Livewire\Livewire;

test('product form creates product', function () {
    $user = User::factory()->create();

    Livewire::test('pages.products.create')
        ->actingAs($user)
        ->set('form.name', 'Test Product')
        ->set('form.description', 'Test Description')
        ->set('form.price', 99.99)
        ->call('create')
        ->assertHasNoErrors();

    expect(Product::where('name', 'Test Product')->exists())->toBeTrue();
});
</code-snippet>


### Common Patterns


<code-snippet name="CRUD with single-file component" lang="php">
<?php

use App\Models\Product;
use Livewire\Component;

new class extends Component {
    public $editing = null;
    public $search = '';

    public function getProductsProperty()
    {
        return Product::when($this->search, fn($q) => $q->where('name', 'like', "%{$this->search}%"))->get();
    }

    public function edit(Product $product) { $this->editing = $product->id; }
    public function delete(Product $product) { $product->delete(); }
} ?>

<!-- HTML / UI Here -->
</code-snippet>

<code-snippet name="Real-Time Search" lang="php">
    <flux:input
        wire:model.live.debounce.300ms="search"
        placeholder="Search..."
    />
</code-snippet>

<code-snippet name="Loading states" lang="php">
    <flux:button wire:click="save" wire:loading.attr="disabled">
        <span wire:loading.remove>Save</span>
        <span wire:loading>Saving...</span>
    </flux:button>
</code-snippet>


=== pint/core rules ===

## Laravel Pint Code Formatter

- You must run `vendor/bin/pint --dirty` before finalizing changes to ensure your code matches the project's expected style.
- Do not run `vendor/bin/pint --test`, simply run `vendor/bin/pint` to fix any formatting issues.


=== phpunit/core rules ===

## PHPUnit Core

- This application uses PHPUnit for testing. All tests must be written as PHPUnit classes. Use `php artisan make:test --phpunit <name>` to create a new test.
- If you see a test using "Pest", convert it to PHPUnit.
- Every time a test has been updated, run that singular test.
- When the tests relating to your feature are passing, ask the user if they would like to also run the entire test suite to make sure everything is still passing.
- Tests should test all of the happy paths, failure paths, and weird paths.
- You must not remove any tests or test files from the tests directory without approval. These are not temporary or helper files, these are core to the application.

### Running Tests
- Run the minimal number of tests, using an appropriate filter, before finalizing.
- To run all tests: `php artisan test`.
- To run all tests in a file: `php artisan test tests/Feature/ExampleTest.php`.
- To filter on a particular test name: `php artisan test --filter=testName` (recommended after making a change to a related file).


=== tailwindcss/core rules ===

## Tailwind Core

- Use Tailwind CSS classes to style HTML, check and use existing tailwind conventions within the project before writing your own.
- Offer to extract repeated patterns into components that match the project's conventions (i.e. Blade, JSX, Vue, etc..)
- Think through class placement, order, priority, and defaults - remove redundant classes, add classes to parent or child carefully to limit repetition, group elements logically
- You can use the `search-docs` tool to get exact examples from the official documentation when needed.

### Spacing
- When listing items, use gap utilities for spacing, don't use margins.

    <code-snippet name="Valid Flex Gap Spacing Example" lang="html">
        <div class="flex gap-8">
            <div>Superior</div>
            <div>Michigan</div>
            <div>Erie</div>
        </div>
    </code-snippet>


### Dark Mode
- If existing pages and components support dark mode, new pages and components must support dark mode in a similar way, typically using `dark:`.


=== tailwindcss/v3 rules ===

## Tailwind 3

- Always use Tailwind CSS v3 - verify you're using only classes supported by this version.
</laravel-boost-guidelines>